#!%PYTHON_SHEBANG%

# Pull and unpack an image from the open docker registry. The image is intended
# to be ingested by ch-grow.
#
# This script is experimental; a proof of concept. This script does not store
# mage data in OCI format; the image layers are downloaded and unpacked.
#
# Future work may include maniging image changesets, e.g., update and/or
# removals carried out by ch-grow.

import argparse
import collections
import json
import os
import re
import requests
import shutil
import sys
import tarfile

from hashlib import sha256

sys.path.insert(0, (  os.path.dirname(os.path.abspath(__file__))
                    + "/../libexec/charliecloud"))
import version

## Globals ##
session = requests.Session()

## Constants ##

registryBase = 'https://registry-1.docker.io'
authBase     = 'https://auth.docker.io'
authService  = 'registry.docker.io'

# Accepted Docker V2 media types.
# See https://docs.docker.com/registry/spec/manifest-v2-2/
mediaTypes = {
  'manifest_schema1': 'application/vnd.docker.distribution.manifest.v1+json',     # existing format
  'manifest_schema2': 'application/vnd.docker.distribution.manifest.v2+json',     # new format
  'manifest_list':    'application/vnd.docker.distribution.manifest.list.v2+json',
  'container_config': 'application/vnd.docker.container.image.v1+json',
  'layer':            'application/vnd.docker.image.rootfs.diff.tar.gzip',        # layer as a gzipped tar
  'plugins':          'application/vnd.docker.plugin.v1+json'                     # plugin config JSON
}

PROXIES = { "HTTP_PROXY": os.environ.get("HTTP_PROXY"),
            "HTTPS_PROXY": os.environ.get("HTTPS_PROXY"),
            "FTP_PROXY": os.environ.get("FTP_PROXY"),
            "NO_PROXY": os.environ.get("NO_PROXY"),
            "http_proxy": os.environ.get("http_proxy"),
            "https_proxy": os.environ.get("https_proxy"),
            "ftp_proxy": os.environ.get("ftp_proxy"),
            "no_proxy": os.environ.get("no_proxy"),
}

## Classes ##

# TODO: these are copied from ch-grow; update so they share.
class Action_Exit(argparse.Action):
    def __init__(self, *args, **kwargs):
        super().__init__(nargs=0, *args, **kwargs)


class CLI_Version(Action_Exit):
    def __call__(self, *args, **kwargs):
        print(version.VERSION)
        sys.exit(0)


# ATTRIBUTE           DESCRIPTION
# 1. name             The image name.
# 2. reference        Reference used to identify the image in the repository,
#                     e.g., image tag or image digest.
# 3. session          Session with token authorization information.
# 4. manifest         The image manifest (request object).
# 5. manifestDigest   The computed sha256 hash of the manifest json dump (string)
# 6. configDigest     The image container config manfigest digest (json)
# 7. configManifest   The image container sconfig manifest contents (request
#                     object)
class Image:
    def __init__(self, name, reference, tag):
        self.name      = name
        self.reference = reference
        self.tag       = tag
        self.session   = MySession(self)
        self.manifest  = self.data_fetch('manifests',
                                         'manifest_schema2',
                                         self.reference)
        self.manifestDigest = self.digest_compute()
        self.configDigest   = self.manifest.json().get('config').get('digest')
        self.configManifest = self.data_fetch('blobs', 'layer', self.configDigest)

    def data_fetch(self, branch, media, reference):
        self.session.headers.update({ 'Accept': mediaTypes[media] })
        URL = "{}/v2/{}/{}/{}".format(registryBase,
                                      self.name,
                                      branch,
                                      reference)
        print("DEBUG: GET {}".format(URL))
        return session.get(URL,
                           headers=self.session.headers,
                           proxies=PROXIES)
    def digest_compute(self):
        return sha256(json.dumps(self.manifest.json(),
                                 indent=3).encode()).hexdigest()

    def layer_fetch(self, storage):
        # Kludge to make ch-grow dir_image_tmp search happy.
        if self.rootfs:
            base = os.path.join(storage[0], 'rootfs')
        else:
            base = os.path.join(storage[0],
                                "{}:{}".format(self.name.split('/')[-1],
                                               self.tag))
        if os.path.isdir(base):
            print("{} exists, replacing.".format(base))
            shutil.rmtree(base)
        os.makedirs(base)
        os.chdir(base)

        # Get layer digests
        layerDigests = list()
        for layer in self.manifest.json().get('layers'):
            layerDigests.append(layer.get('digest'))

        # Fetch layer archives
        for digest in layerDigests:
            filename = digest.split('sha256:')[-1] + '.tar.gzip'
            r = self.data_fetch('blobs', 'layer', digest)
            open(filename, 'wb').write(r.content)
            tf = tarfile.open(filename)
            tf.extractall()
            os.remove(filename)

    def rootfs_set(self, boolean):
        self.rootfs = boolean

class MySession:
    def __init__(self, image):
        self.token   = self.get_token(image)
        self.headers = self.get_headers()

    def get_headers(self):
        return {'Authorization': 'Bearer {}'.format(self.token)}

    def get_token(self, image):
        tokenService = '{}/token?service={}'.format(authBase, authService)
        scopeRepo    = '&scope=repository:{}:pull'.format(image.name)
        authURL      = tokenService + scopeRepo
        return session.get(authURL, proxies=PROXIES).json()['token']


## Functions ##

# The v2 API needs a way to reference a target image. This function returns the
# the image name and appropiate reference where reference is either the image
# hash (priority) or tag.
def split_image_tag(image):
    image = image.split(':')
    if len(image) == 1:
        name = image[0]
        reference  = 'latest' # use default tag as reference
    else:
        name = image[0]
        reference  = image[1]   # use specified tag as reference
    name = "library/{}".format(name)
    return name, reference


## Main ##

def main():
    ap = argparse.ArgumentParser(
         formatter_class=argparse.RawDescriptionHelpFormatter,
         description='Pull images from Docker repository and unpack them for "ch-grow" ingestion.',
         epilog="""\
  CH_GROW_STORAGE       default for --storage
""")
    ap.add_argument("image",
                    type=str,
                    metavar="IMAGE[:TAG][@DIGEST]",
                    nargs=1,
                    help="image name")
    ap.add_argument("--rootfs",
                    action='store_true',
                    help="store image in directory with 'rootfs' name")
    ap.add_argument("-s", "--storage",
                    type=str,
                    metavar="DIR",
                    nargs=1,
                    help="image storage directory (default: /var/tmp/ch-grow",
                    default=os.environ.get("CH_GROW_STORAGE",
                                           "/var/tmp/ch-v2-api"))
    ap.add_argument("-v", "--version",
                    action=CLI_Version,
                    help="print version and exit")

    if (len(sys.argv) < 2):
        ap.print_help(file=sys.stderr)
        sys.exit(1)

    args = ap.parse_args()

    if '/' in (args.image[0]):
        print("error: '{}': image[:tag][@digest] cannot have '/'".format(args.image[0]))
        sys.exit(1)

    # Docker defines a valid image target as IMAGE[:TAG][@DIGEST] where IMAGE
    # is the image name, TAG is the image tag, e.g., 'latest', '3.9', etc., and
    # DIGEST is an algorithm and hash deliminated by a colon, e.g.,
    # 'hello-world:latest@sha256:(some hash here)'.
    #
    # To get a image manifest and it's blobs we need the image name and a
    # reference (either tag or hash). The following splits the user input and
    # determines the name and reference (with digest having priority over tag).
    img = args.image[0].split('@')
    if len(img) == 1:
        name, tag = split_image_tag(args.image[0])
        reference = tag
    elif len(img) == 2:
        name, tag = split_image_tag(img[0])
        reference = img[-1]
    else:
        print("error: image: invalid image syntax '{}'".format(args.image[0]))
        sys.exit(1)

    image = Image(name, reference, tag)

    if args.rootfs:
        image.rootfs_set(True)
    else:
        image.rootfs_set(False)

    image.layer_fetch(args.storage)

    return 0

## Bootstrap ##

if __name__ == "__main__":
    main()
