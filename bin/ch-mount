#!/bin/sh

set -e

. $(dirname "$0")/base.sh

usage () {
    cat 1>&2 <<EOF

Mount a Charliecloud filesystem image and bind mount the specified host
directories at the locations inside the image.

Usage:

  $ $(basename $0) [-t TARGET] [--unsafe] IMAGE [[HOSTDIR TARGET] ...]

Various host directories such as /dev and /proc and files such as /etc/passwd
are bind-mounted into the image. This is so that the image is functional and
has the same user/group mapping as the host after chroot(2).

Any number of host directories can be mounted inside the image. Mount points
within the image are relative to the image root, regardless of whether they
are relative or absolute, and they must already exist.

This script is intended for use by system administrators, not end users.
Arguments are not sanitized.

Example:

  $ ls /foo
  bar baz
  $ ls /udroot
  $ $(basename $0) foo.img /udroot /foo /zzz
  $ ls -R /udroot
  bin dev etc home lib lib64 ... zzz
  [...]
  zzz:
  bar baz
  [...]

EOF
    exit 1
}

bindmount () {
    hostdir="$1"
    options="${3-$MOUNTOPTS}"
    if [ "$2" = '-' ]; then
        guestdir="$MOUNTPOINT$hostdir"
    else
        guestdir="$MOUNTPOINT$2"
    fi
    if [ -e "$hostdir" -a -e "$guestdir" ]; then
        mount --make-slave --bind "$hostdir" "$guestdir"
        mount -o remount,bind,"$options" "$guestdir"
    fi
}

MOUNTPOINT=/chmnt
MOUNTOPTS='nodev,nosuid'

while true; do
    case $1 in
        -h|--help)
            usage
            ;;
        -t|--target)
            if [ -n "$2" ]; then
                MOUNTPOINT="$2"
                shift
            else
                usage
            fi
            ;;
        --unsafe)
            UNSAFE=yes
            MOUNTOPTS=''
            ;;
        *)
            break
    esac
    shift
done

if [ "$#" -lt 1 ]; then
    usage
fi

IMAGE="$1"
shift

if ( fgrep -q "$MOUNTPOINT" /proc/mounts ); then
    echo "something already mounted on $MOUNTPOINT" 1>&2
    exit 1
fi

# If there's some error during setup, we need to leave things in a safe state
# rather than an unknown one. The easiest safe state is unmounted. Note that
# this is quite aggressive and might crash your system for some errors, e.g.
# if $MOUNTPOINT is /dev.
#umount_all () {
#    umount --recursive --force "$MOUNTPOINT"
#}
#trap umount_all EXIT

# The image
mount -o ro,loop,nodev,nosuid "$IMAGE" "$MOUNTPOINT"

# Standard host directories we want to keep
bindmount /dev - ro,nosuid
bindmount /tmp -

# Minimal configuration files
bindmount /etc/passwd - ro,nodev,nosuid
bindmount /etc/group - ro,nodev,nosuid
bindmount /etc/hosts - ro,nodev,nosuid

# tmpfs for /mnt
mount -t tmpfs -o size=4m,$MOUNTOPTS none "$MOUNTPOINT/mnt"
mkdir "$MOUNTPOINT/mnt/host"

# Extra user-specified directories
i=0
while [ "$#" -ge 1 ]; do
    target=/mnt/$i
    mkdir "$MOUNTPOINT/$target"
    bindmount "$1" "$target"
    i=$((i+1))
    shift
done

findmnt -R -o target,fstype,propagation,options "$MOUNTPOINT"

# Make sure that everything is mounted nosuid.
if [ -n "$UNSAFE" ]; then
    echo 'WARNING: Mounting in unsafe mode; not checking for suid filesystems.'
else
    if (findmnt -Rln -o target,options "$MOUNTPOINT" | fgrep -v nosuid); then
        echo 'found suid filesystem(s), aborting' 1>&2
        exit 1
    fi
fi

# We are safe now; no longer need to unmount on exit.
#trap - EXIT
