#!/bin/sh

# The basic algorithm here is that we build up a list of source:destination
# pairs separated by newlines, then walk through them and copy them into the
# image.
#
# The colon separator to avoid the difficulty of iterating through a sequence
# of pairs with no arrays or structures in POSIX sh. We could avoid it by
# taking action immediately upon encountering each file in the argument list,
# but that would (a) yield a half-injected image for basic errors like
# misspellings on the command line and (b) would require the image to be first
# on the command line, which seems awkward.
#
# The newline separator is for the same reason and also because it's
# convenient for input from --cmd and --file.
#
# Note on looping through the newlines in a variable: The approach in this
# script is to set IFS to newline, loop, then restore. This is awkward but
# seemed the least bad. Alternatives include:
#
#   1. Piping echo into "while read -r": This executes the while in a
#      subshell, so variables don't stick.
#
#   2. Here document used as input, e.g.:
#
#        while IFS= read -r FILE; do
#          ...
#        done <<EOF
#        $FILES
#        EOF
#
#      This works but seems more awkward.
#
#   3. Here string, e.g. 'while IFS= read -r FILE; do ... done <<< "$FILES"'.
#      This is a bashism.

LIBEXEC="$(cd "$(dirname "$0")" && pwd)"
. "${LIBEXEC}/base.sh"

# shellcheck disable=SC2034
usage=$(cat <<EOF
Inject files from the host into an image directory.

Usage:

  $ ch-fromhost [OPTION ...] (-c CMD | -f FILE | --nvidia ...) IMGDIR

Which files to inject (one or more required; can be repeated):

  -c, --cmd CMD    listed in the stdout of CMD
  -f, --file FILE  listed in file FILE
  -p, --path PATH  inject the file at PATH
  --cray-openmpi   Cray-enable an OpenMPI installed inside the image
  --nvidia         recommended by nVidia (via "nvidia-container-cli list")

Destination within image:

  -d, --dest DST   place following files in IMGDIR/DST, overriding inference

Options:

  --lib-path       print the inferred destination for shared libraries
  --no-ldconfig    don't run ldconfig even if we injected shared libraries
  -h, --help       print this help and exit
  -v, --verbose    list the injected files
  --version        print version and exit
EOF
)

CRAY_OPENMPI=
DEST=
IMAGE=
NEWLINE='
'
FILES=
LIB_DEST=
LIB_DEST_PRINT=
LIB_FOUND=

debug () {
    if [ "$VERBOSE" ]; then
        printf '%s\n' "$1" 1>&2
    fi
}

ensure_nonempty () {
    [ "$2" ] || fatal "$1 must not be empty"
}

fatal () {
    printf 'ch-fromhost: %s\n' "$1" 1>&2
    exit 1
}

info () {
    printf 'ch-fromhost: %s\n' "$1" 1>&2
}

is_bin () {
    case $1 in
        */bin*)
            return 0
            ;;
        *)
            return 1
    esac
}

is_so () {
    case $1 in
        */lib*)
            return 0
            ;;
        *.so)
            return 0
            ;;
        *)
            return 1
    esac
}

parse () {
    OLD_IFS="$IFS"
    IFS="$NEWLINE"
    D="${DEST:-$2}"
    for F in $1; do
        case $F in
            *:*)
                fatal "paths can't contain colon: $F"
                ;;
        esac
        if is_so "$F"; then
            debug "found shared library; will run ldconfig: $F"
            LIB_FOUND=yes
        fi
        # This adds a delimiter only for the second and subsequent files.
        # https://chris-lamb.co.uk/posts/joining-strings-in-posix-shell
        #
        # If destination empty, we'll infer it later.
        FILES="${FILES:+$FILES$NEWLINE}$F:$D"
    done
    IFS="$OLD_IFS"
}


parse_basic_args "$@"

while [ $# -gt 0 ]; do
    OPT="$1"; shift
    case $OPT in
        -c|--cmd)
            ensure_nonempty --cmd "$1"
            OUT=$($1) || fatal "command failed: $1"
            parse "$OUT"
            shift
            ;;
        --cray-openmpi)
            # We can't act right away because we need the image path.
            CRAY_OPENMPI=yes
            ;;
        -d|--dest)
            ensure_nonempty --dest "$1"
            DEST="$1"
            shift
            ;;
        -f|--file)
            ensure_nonempty --file "$1"
            OUT=$(cat "$1") || fatal "cannot read file: $1"
            parse "$OUT"
            shift
            ;;
        --lib-path)
            # Note: If this is specified along with one of the
            # file-specification options, all the file gathering and checking
            # work will happen, but it will be discarded.
            LIB_FOUND=yes
            LIB_DEST_PRINT=yes
            ;;
        --no-ldconfig)
            NO_LDCONFIG=yes
            ;;
        --nvidia)
            OUT=$(nvidia-container-cli list --binaries --libraries) \
              || fatal "nvidia-container-cli failed; does this host have GPUs?"
            parse "$OUT"
            ;;
        -p|--path)
            ensure_nonempty --path "$1"
            parse "$1"
            shift
            ;;
        -v|--verbose)
            VERBOSE=yes
            ;;
        -*)
            info "invalid option: $OPT"
            usage
            ;;
        *)
            ensure_nonempty "image path" "$OPT"
            [ -z "$IMAGE" ] || fatal "duplicate image: $OPT"
            [ -d "$OPT" ] || fatal "image not a directory: $OPT"
            IMAGE="$OPT"
            ;;
    esac
done

[ "$IMAGE" ] || fatal "no image specified"

if [ $CRAY_OPENMPI ]; then
    # Are we on a Cray?
    SENTINEL=/etc/opt/cray/release/cle-release
    [ -f $SENTINEL ] || fatal "not found: $SENTINEL: are you on a Cray?"

    # Host: Is mpirun in $PATH?
    command -v mpirun >/dev/null 2>&1 || fatal 'mpirun not in $PATH'

    # Ensure matching OpenMPI versions.
    HV=$(mpirun --version) \
      || fatal 'host: mpirun --version failed'
    HV=$(echo "$HV" | head -1 | sed -E 's|^.+ ([0-9.]+)$|\1|')
    GV=$(ch-run "$IMAGE" -- mpirun --version) \
      || fatal 'guest: mpirun --version failed'
    GV=$(echo "$GV" | head -1 | sed -E 's|^.+ ([0-9.]+)$|\1|')
    [ "$HV" = "$GV" ] || fatal "host OpenMPI ($HV) differs from guest ($GV)"

    # Where are lib/openmpi?
    HOST_LIB_OPENMPI=$(  command -v mpirun \
                       | sed -E 's|bin/mpirun$|lib/openmpi|')
    [ "$HOST_LIB_OPENMPI" ] || fatal "host: can't find MCA plugin directory"
    debug "host MCA plugin directory: $HOST_LIB_OPENMPI"
    GUEST_LIB_OPENMPI=$( ch-run "$IMAGE" -- sh -c 'command -v mpirun' \
                       | sed -E 's|bin/mpirun$|lib/openmpi|')
    [ "$GUEST_LIB_OPENMPI" ] || fatal "guest: can't find MCA plugin directory"
    debug "guest MCA plugin directory: $GUEST_LIB_OPENMPI"

    # Note that OpenMPI shared libraries contain a now-erroneous RUNPATH, but
    # the dependencies will still be found in their new location.

    # MCA plugins we need. These go in the guest's plugin directory.
    # Aries network
    parse "$HOST_LIB_OPENMPI/mca_btl_ugni.so" "$GUEST_LIB_OPENMPI"
    # XPMEM CMA
    parse "$HOST_LIB_OPENMPI/mca_btl_vader.so" "$GUEST_LIB_OPENMPI"
    # Authentication tokens to use Aries.
    parse "$HOST_LIB_OPENMPI/mca_plm_alps.so" "$GUEST_LIB_OPENMPI"

    # Dependencies for above. Perhaps in the future these won't be hard-coded.
    parse "$HOST_LIB_OPENMPI/../libmca_common_ugni.so"
    parse /opt/cray/ugni/default/lib64/libugni.so.0
    parse /opt/cray/xpmem/default/lib64/libxpmem.so
    parse "$HOST_LIB_OPENMPI/../libmca_common_alps.so"
    parse /opt/cray/alps/default/lib64/libalpslli.so
    parse /opt/cray/alps/default/lib64/libalpsutil.so
    parse /opt/cray/wlm_detect/default/lib64/libwlm_detect.so
fi

if [ $LIB_FOUND ]; then
    # We want to put the libraries in the first directory that ldconfig
    # searches, so that we can override (or overwrite) any of the same library
    # that may already be in the image.
    debug "asking ldconfig for shared library destination"
    LIB_DEST=$(  "$CH_BIN"/ch-run "$IMAGE" -- /sbin/ldconfig -Nv 2> /dev/null \
               | grep -E '^/' | cut -d: -f1 | head -1)
    [ -z "${LIB_DEST%%/*}" ] || fatal "bad path from ldconfig: $LIB_DEST"
    debug "shared library destination: $LIB_DEST"
fi

if [ $LIB_DEST_PRINT ]; then
    echo "$LIB_DEST"
    exit 0
fi

[ "$FILES" ] || fatal "empty file list"

debug "injecting into image: $IMAGE"

OLD_IFS="$IFS"
IFS="$NEWLINE"
for FILE in $FILES; do
    F="${FILE%%:*}"
    D="${FILE#*:}"
    INFER=
    if is_bin "$F" && [ -z "$D" ]; then
        D=/usr/bin
        INFER=" (inferred)"
    elif is_so "$F" && [ -z "$D" ]; then
        D=$LIB_DEST
        INFER=" (inferred)"
    fi
    debug "  $F -> $D$INFER"
    [ "$D" ] || fatal "no destination for: $F"
    [ -z "${D%%/*}" ] || fatal "not an absolute path: $D"
    [ -d "$IMAGE$D" ] || fatal "not a directory: $IMAGE$D"
    cp --dereference --preserve=all "$F" "$IMAGE/$D" \
      || fatal "cannot inject: $F"
done
IFS="$OLD_IFS"

if [ $LIB_FOUND ] && [ -z "$NO_LDCONFIG" ]; then
    debug "running ldconfig"
    "$CH_BIN"/ch-run -w "$IMAGE" -- /sbin/ldconfig
else
    debug "not running ldconfig"
fi

