#!/bin/bash

. $(dirname "$0")/base.sh

set -e
#set -x

usage () {
    cat 1>&2 <<EOF

Convert a tarball into a mountable filesystem image suitable for chroot'ing.

Usage:

  $ $(basename $0) [--no-scan] TARBALL

The image is saved in the same directory as the tarball. We assume that the
image will be mounted read-only, so minimal extra space beyond the content of
the tarball is provided. As a result, special handling to maintain the sparse
property is not required.

A basic security scan, e.g. removal of setuid binaries and device files, is
performed, unless --no-scan is specified.

This script is intended for use by system administrators, not end users. It
runs on Linux only and requires bash.

EOF
    exit 1
}

while true; do
    case $1 in
        -h|--help)
            usage
            ;;
        --no-scan)
            NOSCAN='.NOSCAN'
            ;;
        *)
            break
            ;;
    esac
    shift
done

if [[ $# -ne 1 ]]; then
    usage
fi

TAR=$1
if [[ ! -f $TAR ]]; then
    echo "not a regular file: $TAR" 1>&2
    exit 1
fi

IMG=$(echo $TAR | sed "s/\.tar\.gz/${NOSCAN}.img/")
TAR_ABS=$(readlink -f $TAR)
MOUNTPOINT=mnt
BLOCKSIZE=4096
GETCAP_OUTFILE=/tmp/getcap.$$

# The filesystem image needs to be larger than the sum of the file sizes in
# the tarball due to various types of overhead. This overhead is hard to
# estimate precisely, so our approach is to be generous and then shrink the
# filesystem to its minimum size and truncate the image.
TARSIZE=$(gzip -l $TAR | tail -1 | awk '{print $2}')
SLUSH_CONST=$((1 * 2**30))
IMGSIZE=$((TARSIZE + SLUSH_CONST))

# Create image.
rm -f $IMG
truncate -s $IMGSIZE $IMG
mkfs.ext4 -q -b$BLOCKSIZE -m0 -O ^has_journal $IMG

# Mount
mkdir $MOUNTPOINT
sudo mount $IMG $MOUNTPOINT
pushd $MOUNTPOINT > /dev/null

# While the image is mounted, need cleanup no matter how we exit.
cleanup_mount () {
    popd > /dev/null
    sudo umount $MOUNTPOINT || true
    rmdir $MOUNTPOINT || true
}
trap cleanup_mount EXIT

# Populate
sudo tar xf $TAR_ABS

# Create mount points expected by Charliecloud
sudo mkdir -p mnt run

# Remove files that seem risky due to any of the following:
#
#   1. type not in the whitelist:
#        d  directories
#        f  regular files
#        l  symbolic links
#        p  named pipes
#   2. regular file with setuid or setgid bits set
#   3. regular file with setcap attribute
#
# As for the setcap attribute (a.k.a. POSIX file capabilities), this is a
# little tricky. GNU find does not currently support searching for file
# capabilities or actually extended attributes (xattrs) at all. We could parse
# getcap -r output to find setcap files, but that seems risky (e.g., filenames
# containing a newline). It seems that while GNU tar does store the setcap
# attributes, it does not currently extract them by default, so we should not
# see any output at all from getcap -r, which is what we test for.
if [[ $NOSCAN ]]; then
    echo "WARNING: not scanning for risky files"
else
    sudo find -P -not \( -type d -o -type f -o -type l -o -type p \) -delete
    sudo find -P -type f -perm /6000 -delete
    sudo getcap -r . | head -1000 > $GETCAP_OUTFILE
    if [[ -s $GETCAP_OUTFILE ]]; then
        echo "setcap files found; see $GETCAP_OUTFILE for details" 1>&2
        exit 1
    fi
    rm $GETCAP_OUTFILE
fi

# Unmount
cleanup_mount
trap - EXIT

# Compact
#
# Note that resize2fs recently became quite a bit more conservative in
# computing the minimum size, so this may not do anything. Ted Ts'o's rather
# obnoxious comments on the matter:
# https://bugs.launchpad.net/ubuntu/+source/e2fsprogs/+bug/1415077
fsck.ext4 -pf $IMG > /dev/null
resize2fs -M $IMG > /dev/null
MIN_BLOCK_CT=$(dumpe2fs $IMG | egrep '^Block count' | awk '{print $3}')
truncate -s $(($MIN_BLOCK_CT*$BLOCKSIZE)) $IMG
fsck.ext4 -nf $IMG > /dev/null

# clean up
chmod 440 $IMG
ls -lh $IMG
